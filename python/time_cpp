#!/usr/bin/env python3

# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import subprocess
import pathlib

import cffi

import load_cpp

topdir = pathlib.Path(__file__).resolve().parent.parent

def timefunc_for(time, params, timeable):
    iters = 1
    remaining = time
    while True:
        t = timeable.time(params, iters)
        #print(f"{func}({n}, {k}) * {iters} = {t}")
        remaining -= t
        if t >= remaining:
            return t / iters
        elif t * 100 > remaining:
            iters = int(iters * remaining / t)
        elif t * 10000 > remaining:
            iters = int(iters * remaining * 0.1 / t)
        else:
            iters *= 10

def run_timings(values, totime, time_for):
    vitr = globals()[f"{values}_values"]
    klim = {}
    for descrip, n, k in vitr():
        print(f"{descrip}")
        res = []
        for name, tm in totime.items():
            if name not in klim or k < klim[name]:
                t = timefunc_for(time_for, (n, k), tm)
                res.append((t, name))
                if t > time_for:
                    print(f"hit tlim: {name}")
                    klim[name] = k
        res.sort()
        if res[0][0] < 1E-6:
            unit = "ns"; mul = 1E9
        elif res[0][0] < 1E-3:
            unit = "Î¼s"; mul = 1E6
        elif res[0][0] < 1:
            unit = "ms"; mul = 1E3
        else:
            unit = "s"; mul = 1
        for t, name in res:
            print(f"{t*mul:12.1f}{unit} {name:20}")
        print()

def small_values():
    top = 11
    for n in range(top):
        for k in range(n+1):
            yield f"n = {n}, k = {k}", n, k

def large_values():
    ptop = 9
    klim = {}
    for pn in range(ptop):
        for pk in range(pn):
            yield f"n = 10^{pn}, k = 10^{pk}", 10**pn, 10**pk

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("--time-for", type=float, default=0.1)
    p.add_argument("--sorttype", default="random")
    p.add_argument("--values", action='append')
    return p.parse_args()

def main():
    args = parse_args()
    print()
    for k, v in sorted(vars(args).items()):
        print(f"{k}: {v}")
    print()
    timeables = load_cpp.get_timeables(topdir)
    t = timefunc_for(args.time_for, (0, 0), timeables["donothing"]["donothing"])
    print(f"donothing: {t*1E9:7.1f}ns")
    values = args.values
    if values is None:
        values = ["large"]
    for v in values:
        run_timings(v, timeables[args.sorttype], args.time_for)

if __name__ == '__main__':
    main()
