#!/usr/bin/env python3

# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import sys
import subprocess
import pathlib

import cffi

topdir = pathlib.Path(__file__).resolve().parent.parent

samplers = [
    "quadraticreject",
    "cardchoose",
    "fisheryates",
    "floydf2",
    "iterativechoose",
    "rejectionsample",
    "selby_fy"
]

def list_functions():
    yield "donothing"
    for prefix in ["sorted", "random"]:
        for t in samplers:
            yield f"{prefix}_{t}"

def setup_module(args):
    cppdir = topdir / "cpp"
    b = str(cppdir / "build/host")
    subprocess.run(["ninja", "-C", b], check=True)
    ffi = cffi.FFI()
    ffi.cdef("""
        void rand_init();
        typedef unsigned uint32_t;
        double timefunc_s(uint32_t iters, uint32_t n, uint32_t k,
                                                      void (*func)(uint32_t n, uint32_t k,
                                                                   uint32_t* result));
    """)
    source = """
        #include "randbelow.h"
        #include "timing.h"
    """
    for f in list_functions():
        ffi.cdef(f"void (*const {f})(uint32_t n, uint32_t k, uint32_t* result);")
        source += f"void {f}(uint32_t n, uint32_t k, uint32_t* result);\n"
    ffi.set_source("sansreplace", source,
        include_dirs=[str(cppdir)],
        library_dirs=[b],
        runtime_library_dirs=[b],
        libraries=["sansreplace"],
        extra_compile_args=['-std=c11'],
        extra_link_args=[f"-Wl,-rpath,{b}"])
    ffi.compile(tmpdir=b)
    sys.path.append(b)
    import sansreplace as s
    global sansreplace
    sansreplace = s
    sansreplace.lib.rand_init()

def timefunc_for(time, n, k, func):
    fpointer = getattr(sansreplace.lib, func)
    iters = 1
    remaining = time
    while True:
        t = sansreplace.lib.timefunc_s(iters, n, k, fpointer)
        #print(f"{func}({n}, {k}) * {iters} = {t}")
        remaining -= t
        if t >= remaining:
            return t / iters
        elif t * 100 > remaining:
            iters = int(iters * remaining / t)
        elif t * 10000 > remaining:
            iters = int(iters * remaining * 0.1 / t)
        else:
            iters *= 10

def run_timings(args, values):
    vitr = globals()[f"{values}_values"]
    klim = {}
    for descrip, n, k in vitr():
        print(f"{descrip}, {args.sorttype}")
        res = []
        for func in samplers:
            if func not in klim or k < klim[func]:
                t = timefunc_for(args.time_for, n, k, f"{args.sorttype}_{func}")
                res.append((t, func))
                if t > args.time_for:
                    print(f"hit tlim: {func}")
                    klim[func] = k
        res.sort()
        if res[0][0] < 1E-6:
            unit = "ns"; mul = 1E9
        elif res[0][0] < 1E-3:
            unit = "Î¼s"; mul = 1E6
        elif res[0][0] < 1:
            unit = "ms"; mul = 1E3
        else:
            unit = "s"; mul = 1
        for t, func in res:
            print(f"{t*mul:12.1f}{unit} {func:20}")
        print()

def small_values():
    top = 11
    for n in range(top):
        for k in range(n+1):
            yield f"n = {n}, k = {k}", n, k

def large_values():
    ptop = 9
    klim = {}
    for pn in range(ptop):
        for pk in range(pn):
            yield f"n = 10^{pn}, k = 10^{pk}", 10**pn, 10**pk

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("--time-for", type=float, default=0.1)
    p.add_argument("--sorttype", default="random")
    p.add_argument("--values", action='append')
    return p.parse_args()

def main():
    args = parse_args()
    print()
    for k, v in sorted(vars(args).items()):
        print(f"{k}: {v}")
    print()
    setup_module(args)
    t = timefunc_for(args.time_for, 0, 0, "donothing")
    print(f"donothing: {t*1E9:7.1f}ns")
    values = args.values
    if values is None:
        values = ["large"]
    for v in values:
        run_timings(args, v)

if __name__ == '__main__':
    main()
