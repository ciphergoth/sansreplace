% Copyright 2018 Google LLC
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%     https://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

%!TeX spellcheck = en-US

\documentclass[letterpaper,luatex,11pt]{article}

\usepackage{fontspec}
\usepackage[hmargin=4cm,vmargin=3cm,nohead]{geometry}
\usepackage{parskip}
\usepackage[style]{abstract}
\usepackage{titling}
\usepackage{sectsty}
\usepackage{authblk}
\usepackage{floatrow}
\usepackage[svgnames]{xcolor}
\usepackage[breaklinks,colorlinks,urlcolor=DarkBlue,linkcolor=DarkRed,citecolor=DarkGreen]{hyperref}
\usepackage[style=alphabetic,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[landau,operators,probability,sets]{cryptocode}
\usepackage[cachedir=build/_minted-cardchoose]{minted}

\addbibresource{bib.bib}

\setmainfont{TeX Gyre Pagella}
\setsansfont{TeX Gyre Heros}
\setmathrm{Latin Modern Roman}
\defaultfontfeatures{}
\setmonofont{TeX Gyre Cursor}[Ligatures={NoCommon,NoRequired,NoContextual},Scale=0.9]

\pretitle{\begin{center}\LARGE\bfseries\sffamily} % sf title
\renewcommand{\abstitlestyle}{\sffamily\bfseries\centering} % sf abstract
\allsectionsfont{\sffamily} % sf sections

\raggedright
\raggedbottom

\DeclareMathOperator{\Supp}{Supp}

\title{A new algorithm for sampling with replacement}
\author{Paul~Crowley}
\affil{Google LLC}

\begin{document}
\maketitle

\section{Introduction}

Many ways of fairly choosing $k$ distinct integers from $\{0 \ldots n-1\}$ are in the literature.
However, they either require a hash-based data structure such as a set or dictionary, or
show asymptotically poor performance for some values of $k, n$. We present here an algorithm
that requires no such data structure or auxiliary storage, only an integer sort taking
$\bigO{k \log k}$ time. In Python the algorithm works as follows:

\inputminted{Python}{cardchoose.py}

\section{Intuition behind the algorithm}

Every way of choosing 6 integers from the range $\{0 \ldots 10\}$ is equivalent to a way of
arranging 6 stars and 5 bars into a sequence;
there are $\binom{6 + 5}{6}$ ways of doing so.
To choose one fairly, we start with a sequence of five bars \(|||||\) and insert six stars,
one after another, in randomly chosen positions.

For the first star, there are six possible places it can go, and we choose one at random:
\(|||\star||\). We record that it has three bars to its left \(\{3\}\).

There are now six items in the sequence, and thus seven possible places to place the second star.
In two of those seven cases---before the existing star, and after it---it will have three bars
to its left. Let's suppose we choose the first position: \(\star|||\star||\). We append
the number of bars to the left of the new star to our record, which becomes \(\{3, 0\}\).
The positions have changed from \(\{3\}\)
to \(\{4, 0\}\) but because we're not recording positions, only bars to the left, we don't need to
update the first entry.

We place three more stars in random positions, ending up with \(\star\star\star|\star||\star||\)
and a record of \(\{3, 0, 0, 1, 0\}\). Now there's one star left to place; there is one
position it can be placed after the last bar, but four before the first bar, so it is four times
more likely to be placed before the first bar than after the last. Let's suppose it's placed
at the fifth position: \(\star\star\star|\star\star||\star||\), \(\{3, 0, 0, 1, 0, 1\}\) We now
want to know the position of each star; we find this by sorting the list \(\{0, 0, 0, 1, 1, 3\}\)
and adding to each entry its index so that the value reflects the stars as well as the bars to its
left, returning the answer $\{0, 1, 2, 4, 5, 8\}$

\begin{displaymath}
\begin{array}{ c c c c c c c c c c c }
    0 & 0 & 0 & & 1 & 1 & & & 3 & & \\
    \star & \star & \star & \big| & \star & \star & \big| & \big| & \star & \big| & \big| \\
    0 & 1 & 2 & & 4 & 5 & & & 8 & & \\
\end{array}
\end{displaymath}

Thus to get a sequence without duplicates, we start with a procedure that deliberately
biases towards duplicates.

\section{Multisets}

A \emph{multiset} is an extension of a set in which elements can appear more than once.
$[0, 1, 1]$ is the same multiset as $[1, 0, 1]$ but distinct from $[0, 0, 1]$.
The algorithm works by choosing a multiset at random, then converting that to a choice
of subset.

We represent multisets as functions $m: U \rightarrow \NN$; the set $U$ is the \emph{universe},
and in what follows we consider only finite universes. For any $y \in U$ we call
$m(y)$ the \emph{multiplicity} of $y$ in $m$.
A multiset has a \emph{cardinality} $|m| = \sum_{x \in U} m(x)$
and a \emph{support} set $\Supp(m) = \{x \in U: m(x) > 0\}$.

Where $U$ is clear from context, for any set $S \subseteq U$ we consider
$\overline{S}$ to be $S$ viewed as a multiset, ie the multiset
such that $\Supp(\overline{S}) = S$ and $|\overline{S}| = |S|$:
\begin{displaymath}
    \overline{S}(x) =
    \begin{cases}
        1 & \text{if $x \in S$} \\
        0 & \text{otherwise} \\
    \end{cases}
\end{displaymath}

The sum of multisets $m_1 \uplus m_2$ is the multiset such that
$(m_1 \uplus m_2)(x) = m_1(x) + m_2(x)$ for all $x \in U$.
$m = m_1 \ominus m_2$ is the unique multiset such that $m_1 = m \uplus m_2$,
and is defined only if this exists.

We define random sampling from a multiset to be analogous to drawing from a set,
where each element's probability of being drawn is proportional to its multiplicity:
$\prob{x = y |x \sample m} = \frac{m(y)}{|m|}$.

Define $\mathcal{M}(U, k) = \{m \in U \rightarrow \mathbb{N}: |m| = k\}$ the set of multisets over
universe \(U\) of cardinality \(k\). The ``stars and bars'' method
shows that for a set \(S\) and for any \(U\) and \(k\) such that \(|S| = |U| + k - 1\), 
there is a bijection between \(\mathcal{M}(U, k)\) and the set of 
cardinality \(k\) subsets of \(S\), from which we infer that 
$|\mathcal{M}(U, k)| = \binom{|U| + k - 1}{k}$ wherever \(|U| + k > 0\).

\section{Multiset choosing}

We consider the problem of choosing an element from $\mathcal{M}(U, k)$ fairly.
For example, $\mathcal{M}(\bin, 3) = \{[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1]\}$; for each of
these four, our algorithm should output it with probability $\frac{1}{4}$. If we choose
three independent elements from $U$ and add them together to make a multiset, our answer
will favour multisets with lower multiplicities; in accordance
with the binomial theorem, $[0, 0, 0]$ will be drawn with probability $\frac{1}{8}$, while
$[0, 0, 1]$ will be drawn with probability $\frac{3}{8}$, reflecting the three ways this multiset
can be written as a sequence.

%It is straightforward to show by
%induction that in general, this naive method chooses $m \in \mathcal{M}(U, k)$
%with probability

%\begin{displaymath}
%    \frac{k!}{{|U|}^k \prod_{x \in U} m(x)!}
%\end{displaymath}

\begin{algorithm}
\caption{Fair multiset choosing}
\begin{algorithmic}[0]
\Procedure{ChooseMultiset}{$U, k$}
    \If{k = 0}
        \State \textbf{return} $\overline{\varnothing}$
    \Else
        \State $m' \leftarrow \textproc{ChooseMultiset}(U, k-1)$
        \State $x \sample \overline{U} \uplus m'$
        \State \textbf{return} $m' \uplus \overline{\{x\}}$
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

To address this, in \textproc{ChooseMultiset}
we introduce a counter-bias in the selection of $x$, which favours duplicates.
\textproc{ChooseMultiset} is trivially fair for $k = 0$, so
we assume it is fair for $k - 1$ and proceed by induction.
For a multiset $m \in \mathcal{M}(U, k)$:

\begin{align*}
    &\prob{\textproc{ChooseMultiset}(U, k) \rightarrow m}
    \\
    =&
    \prob{m' \uplus \overline{\{x\}} = m
        | m' \leftarrow \textproc{ChooseMultiset}(U, k-1), x \sample \overline{U} \uplus m'}
    \\
    =&
    \prob{m' \uplus \overline{\{x\}} = m
        | m' \sample \mathcal{M}(U, k-1), x \sample \overline{U} \uplus m'}
    \\
    =&
    \sum_{y \in \Supp(m)}
    \prob{m' = m \ominus \overline{\{y\}} | m' \sample \mathcal{M}(U, k-1)}
    \prob{x = y | x \sample \overline{U} \uplus (m \ominus \overline{\{y\}})}
    \\
    =&
    \sum_{y \in \Supp(m)}
    \frac{1}{|\mathcal{M}(U, k-1)|}
    \frac{(U \uplus (m \ominus \overline{\{y\}}))(y)}{|U \uplus (m \ominus \overline{\{y\}})|}
    \\
    =&
    \frac{1}{|\mathcal{M}(U, k-1)|}
    \sum_{y \in \Supp(m)}
    \frac{1 + (m \ominus \overline{\{y\}})(y)}{|U| + |m \ominus \overline{\{y\}}|}
    \\
    =&
    \frac{1}{|\mathcal{M}(U, k-1)|}
    \sum_{y \in \Supp(m)}
    \frac{m(y)}{|U| + k -1}
    \\
    =& \frac{k}{(|U| + k -1)|\mathcal{M}(U, k-1)|}
    \\
    =& \frac{k}{(|U| + k -1)\binom{|U| + k - 2}{k-1}}
    \\
    =& \frac{1}{\binom{|U| + k - 1}{k}}
    \\
    =& \frac{1}{|\mathcal{M}(U, k)|}
\end{align*}

This algorithm is straightforward to implement. This Python implementation takes integers
$n, k$ and returns a sorted list of integers in $\{0 \ldots n-1\}$.

\inputminted{Python}{choose_multiset.py}

\section{Multisets and choices}


To generate a random \(k\)-element subset of \(\{0 \ldots n-1\}\),
we can apply this method to generate a random multiset from the universe \(\{0 \ldots n-k\}\)
and use the ``stars and bars'' bijection to convert to the desired subset.

Our implementation of \textproc{ChooseMultiset}
represents its result in $\mathcal{M}([0 \ldots n-k], k)$ as a sorted list of integers.
In ``stars and bars'' representation,
each entry in the list represents a star, and the integer is the number of bars to its left.
Converting this to a sorted \(k\)-element subset of \(\{0 \ldots n-1\}\) simply means adding to each
the number of stars to its left, which is equal to its position in the sequence; the Python code
below returns a sorted list of $k$ distinct integers in $[0 \ldots n-1]$ fairly among all ways
of doing so.

\inputminted{Python}{choose_binom.py}

\printbibliography

\end{document}
